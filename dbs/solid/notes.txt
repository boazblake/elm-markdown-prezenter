SOLID PRINCIPLES of Object Orientated Programing

intro
  Exciting times at Empyrean
   ~ building new applications ~
   ~ building new versions of exisiting applications ~

What goes wrong with software?
-----------------------------
Most software engineers don’t set out to create “bad designs”. Yet most software
eventually degrades to the point where someone will declare the design to be unsound.
Why does this happen? Was the design poor to begin with, or did the design actually
degrade like a piece of rotten meat? Uncle Bob
*** http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod

SLIDE 1 ==============================================================================================
On Good Design
--------------
The key in making great and growable systems is much more to design how its
modules communicate rather than what their internal properties and
behaviors should be. Alan Kay
*** http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html

SLIDE 2 ==============================================================================================
On Bad Design
--------------
At the heart of this issue is our lack of a good working definition of “bad” design.
***  Uncle Bob: http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod

I would say that a system that allowed other metathings to be done in the ordinary course of
programming (like changing what inheritance means, or what is an instance) is a bad design.
Alan Kay
*** http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html


A piece of software that fulfills its requirements and yet exhibits any or all of the following
three traits has a bad design.
***  Uncle Bob: http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod

1. Rigidity -> It is hard to change. (because every change affects too many other parts of the system.)
2. Fragility -> When you make a change, unexpected parts of the system break.
3. Immobility -> It is hard to reuse in another application. (because it cannot be disentangled from the current application)

SLIDE 3 ==============================================================================================
Computer Programming Paradigms
===============================
Object Orientated Programing is catagrorized as part of the Structured Paradigms of computer programming paradigms.
OOP ranges from:
  * pure OO languages such as : Python, Ruby, Scala, Smalltalk, Eiffel
  * Languages designed mainly for OO programming: Java, C++, C#, <<= these are Class-Orientated not Object Orientated
  * Languages that are historically procedural languages: PHP Fortran, matlab

Object Orientated Programing
 Smalltalk.

Idea :
    obj {}
      -> have a notion of this
      -> data would be perfectly encapsulate as attributes
      -> communicate with messages to other objects using API

      (was to have data perfectly encapsulated as attributes of objects with the notion of "self/this"
      and would be able to manipulate the data with private methods and communicate with other objects
      using public methods sending messages.)

SLIDE 4 ==============================================================================================
Criticisms of OOP
Luca Cardelli has claimed that:
   OOP code is "intrinsically less efficient" than procedural code,
  that OOP can take longer to compile, and
  that OOP languages have "extremely poor modularity properties with respect to class extension and modification",
  and tend to be extremely complex.

  ***The problem with object-oriented languages is they've got all this implicit
   environment that they carry around with them.
   You wanted a banana but what you got was a gorilla holding the banana and the entire jungle. 
      Joe Armstrong, the principal inventor of Erlang:


SLIDE 5 ==============================================================================================
Rebuttels from OO commmunity
  *** Object-oriented programming is more than just classes and objects;
  it's a whole programming paradigm based around objects (data structures)
  that contain data fields and methods.
  It is essential to understand this;
  using classes to organize a bunch of unrelated methods together is not object orientation.
      Junade Ali, Mastering PHP Design Patterns

  ***Douglas Crockford:
    "you make prototype objects, and then … make new instances.
    Objects are mutable in JavaScript, so we can augment the new instances, giving them new fields and methods.
    These can then act as prototypes for even newer objects.
    We don't need classes to make lots of similar objects… Objects inherit from objects.
    What could be more object oriented than that?"

SLIDE 6 ==============================================================================================
Classical vs prototypical inheritance*
TLDR;
How the confusion began:
B.Eich (js inventor) worked at Netscape who wanted to use the marketing of Java
so they sold JS as Class-ical inheritance program langaguge instead of using it
how it was intended.
How to solve:
use OLOO and MOP (not classical).


SLIDE 6B ==============================================================================================
* inheritance means copy (with no link -- think biology) is a misnomer for prototypical ... better word is delegation.

prototypical inheritance
------------------------
thanks to Doug Crockford (JavaScript the good parts, monads and gonads) we have
built in to ES5:

where `o` is the object we wish to delegate to

```function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
};
```
* Prototype object oriented programming uses generalized objects, which can be cloned and extended.
* Class-based paradigm, uses generalized Classes which are extended when used by another class.

              PROTOTYPICAL INHERITANCE || CLASSICAL INHERITANCE
              ==================================================
ABSTRACTIONS||  object <- object       || classes -> objects   ||   the direction of the arrows...
----------------------------------------------------------------
Differences ||  var human = {}         || class Human = {}
            ||  var man =              || class Man extends Human = {}
     in     ||     Object.create(human)|| Boaz extends new Man()
            ||  var Boaz =             ||
inheritance ||     Object.create(human)||
----------------------------------------------------------------
                Factory Functions      || tight coupling ->
                                       ||       refactoring ripples
                                       ||       -> gorilla/banana
                                       ||       -> gorilla/banana
                                       ||       -> viscosity DRY etc
                *can create and        ||       -> have to create and instantiate at same time
                instantiate at
                different time



D. crockford created Object.create, which stops us needing to use classes.
http://imagizer.imageshack.us/a/img911/5519/fxn2D3.png

SLIDE 6C ==============================================================================================
Message-Oriented Programming
-----------------------------
We use abstractions when we program. The types of abstractions we use generally fall under different programming methodologies.
In object-oriented programming, we use objects as the core abstraction along with attributes, methods, variables and parameters (to name a few).
In functional programming, the core abstraction is functions along with parameters and variables (to name a few).
In message-oriented programming (not to be confused with messaging systems and frameworks), messages and properties are the only abstractions. There are no methods, functions, parameters, variables and so on. A property of a message contains a single message or a composition of messages.
A composition of messages is really a data structure. This means that our programs are actually data structures and, as such, can be manipulated just like you would any data structure. Want to duplicate and run part of a program in it’s own thread? Just copy the program from that point, as you would any data structure, and run it.
Want to store part of your program? Just point at any part of your program and save it as you would any data structure.
***http://blog.interfacevision.com/design/design-mop-and-javascript/

-> actor model in JS: https://monades.roperzh.com/get-to-know-the-actor-model/

-> reactive manifesto (https://www.reactivemanifesto.org/)

SLIDE 7 ==============================================================================================
luckily we have GOF and POOD

The Gang of Four design patterns
***Design Patterns: Elements of Reusable Object-Oriented Software
  by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides,

Creational patterns (5): Factory method pattern, Abstract factory pattern, Singleton pattern, Builder pattern, Prototype pattern
Structural patterns (7): Adapter pattern, Bridge pattern, Composite pattern, Decorator pattern, Facade pattern, Flyweight pattern, Proxy pattern
Behavioral patterns (11): Chain-of-responsibility pattern, Command pattern, Interpreter pattern, Iterator pattern, Mediator pattern, Memento pattern, Observer pattern, State pattern, Strategy pattern, Template method pattern, Visitor pattern

And Principles of Ood
***http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod
  - 11 Principles promoted by Robert C. Martin
  - Detailing how to design and package software.
  - first 5 of 11 principles detailing how to design code.
  - term coined by Michael Feathers
  - SOLID PRINCIPLES

SLIDE 8 ==============================================================================================

Efficient code organization is about Dependency Management.
***Uncle Bob

SOLID principles
    * Single Responsibility
    * Open/closed
    * Liskov substitution
    * Interface segregation
    * Dependency inversion

SLIDE 9 ==============================================================================================
  * Single Responsibility
    - cohesion -> derives from the functional relatedness of elements in a module.
    - An object should have a cohesive set of behaviors together comprising a single responsibility that,
      if changed, would require the modification of the object’s definition.
      -> improve testing
      -> improved code reliability
  - code smells:
    -> large setups for testing,
    ->  more than one contextually different piece of code

SLIDE 9 B ==============================================================================================
How to know if the entity is cohesive?

borrowing from

Object Oriented Role Analysis and Modeling:
  the method focuses on describing patterns of interaction without connecting the interaction to particular objects/instances.

 we can group behaviors into cohesive groups of responsibilities related to the object’s intended role

Entity Role Stereotypes
* Information holder – an object designed to know certain information and provide that information to other objects.
* Structurer – an object that maintains relationships between objects and information about those relationships.
* Service provider – an object that performs specific work and offers services to others on demand.
* Controller – an object designed to make decisions and control a complex task.
* Coordinator – an object that doesn’t make many decisions but, in a rote or mechanical way, delegates work to other objects.
* Interfacer – an object that transforms information or requests between distinct parts of a system.

      ***http://aspiringcraftsman.com/2011/12/08/solid-javascript-single-responsibility-principle/


SLIDE 9 C ==============================================================================================
SRP KATA



SLIDE 10 ==============================================================================================
  * Open/closed
    - Foundation for building reusable maintainable code
    - Abstractions
        * open for extension -> the ability for an entity to be adapted when changes occur
        * closed to modification. -> the change should not modify the behaviour of the element.

  Applying the open-closed principle:
      -> loose coupling
      -> improve readability
      -> reducing the risk of breaking existing functionality.

SLIDE 10 B ==============================================================================================


SLIDE 11 ==============================================================================================
  * Liskov substitution
    if S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that program
    - extension of the OCP
      -> “a violation of LSP is a latent violation of OCP”.

  Any extended entity should be able to replace the entity which it is an extension of without modifiyng behavior of application

SLIDE 11 B ==============================================================================================



SLIDE 12 ==============================================================================================
  * Interface segregation
cont from http://aspiringcraftsman.com/2012/01/08/solid-javascript-the-interface-segregation-principle/  An entity should not have any methods that it does not use

SLIDE 13 ==============================================================================================
  * Dependency inversion
  cont from   http://aspiringcraftsman.com/2012/01/22/solid-javascript-the-dependency-inversion-principle/
    “High level modules should not depend on low level modules rather both should depend on abstraction. Abstraction should not depend on details; rather detail should depend on abstraction.”

      Abstractions
    ---------------
      Concretions

    - Dependency Injection

SLIDE 14 ==============================================================================================
Conclusion