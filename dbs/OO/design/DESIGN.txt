SOLID PRINCIPLES of Object Orientated Programing

intro
  "a significant barrier to progress in computer science is the
  fact that many practitioners are ignorant of the history of
  computer science: old accomplishments (and failures!) are
  forgotten, and consequently the industry reinvents itself every
  5-10 years. <Alan Kay>" The Cuneiform Tablets of 2015
  http://www.vpri.org/pdf/tr2015004_cuneiform.pdf



What goes wrong with software?
-----------------------------
Most software engineers don’t set out to create “bad designs”. Yet most software
eventually degrades to the point where someone will declare the design to be unsound.
Why does this happen? Was the design poor to begin with, or did the design actually
degrade like a piece of rotten meat? Uncle Bob
*** http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod

SLIDE 1 ==============================================================================================
On Good Design
--------------
The key in making great and growable systems is much more to design how its
modules communicate rather than what their internal properties and
behaviors should be. Alan Kay
*** http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html

SLIDE 2 ==============================================================================================
On Bad Design
--------------
At the heart of this issue is our lack of a good working definition of “bad” design.
***  Uncle Bob: http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod

I would say that a system that allowed other metathings to be done in the ordinary course of
programming (like changing what inheritance means, or what is an instance) is a bad design.
Alan Kay
*** http://lists.squeakfoundation.org/pipermail/squeak-dev/1998-October/017019.html

A piece of software that fulfills its requirements and yet exhibits any or all of the following
three traits has a bad design.
***  Uncle Bob: http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod

1. Rigidity -> It is hard to change. (because every change affects too many other parts of the system.)
2. Fragility -> When you make a change, unexpected parts of the system break.
3. Immobility -> It is hard to reuse in another application. (because it cannot be disentangled from the current application)

SLIDE 3 ==============================================================================================

The principle of parsimony in science popularized by Occam's razor
  "the simpleset solution is generely the correct one"

 and more recently by Hanlon's razor:
 "Never attribute to malice that which is adequately explained by stupidity"

actually goes deeper and applies to CS as well - the less complex the system - the more correct it will tend to be.

Patterns are repetitive designs, they are simplified solutions to common problems.

The Gang of Four design patterns
***Design Patterns: Elements of Reusable Object-Oriented Software
  by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides,

Creational patterns (5): Factory method pattern, Abstract factory pattern, Singleton pattern, Builder pattern, Prototype pattern
Structural patterns (7): Adapter pattern, Bridge pattern, Composite pattern, Decorator pattern, Facade pattern, Flyweight pattern, Proxy pattern
Behavioral patterns (11): Chain-of-responsibility pattern, Command pattern, Interpreter pattern, Iterator pattern, Mediator pattern, Memento pattern, Observer pattern, State pattern, Strategy pattern, Template method pattern, Visitor pattern

Prinicples are rules we can use to constrain our code which helps to keep our code simple and bug free.
  ergo ->
    the more constrains we are able to apply and work with ->
      the simnpler and healthier code base ->
        ergo -> FP etc


Being able to recognize and use patterns and constraining ourselevs to certain principles is essential to maintaining a healthy code base.

Principles of Object Oreinted Desirn
***http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod
  - 11 Principles promoted by Robert C. Martin
  - Detailing how to design and package software.
  - first 5 of 11 principles detailing how to design code.
  - term coined by Michael Feathers
  - SOLID PRINCIPLES

SLIDE 4 ==============================================================================================

Efficient code organization is about Dependency Management.
***Uncle Bob

SOLID principles
    * Single Responsibility
    * Open/closed
    * Liskov substitution
    * Interface segregation
    * Dependency inversion

SLIDE 5 ==============================================================================================
  * Single Responsibility
    - cohesion -> derives from the functional relatedness of elements in a module.
    - An object should have a cohesive set of behaviors together comprising a single responsibility that,
      if changed, would require the modification of the object’s definition.
      -> improve testing
      -> improved code reliability
  - code smells:
    -> large setups for testing,
    ->  more than one contextually different piece of code

SLIDE 5 B ==============================================================================================
How to know if the entity is cohesive?

Object Oriented Role Analysis and Modeling:
* http://www.idi.ntnu.no/grupper/su/publ/html/totland/ch0528.htm
* http://www.wirfs-brock.com/PDFs/A_Brief-Tour-of-RDD.pdf

In OORAM
Objects are structured according to their interactions (note that object relations are not stressed).
  - has state (i.e., attributes) providing memory;
  - has behavior, supporting dynamic aspects;
  - it is encapsulated to hide complexity.

 Objects play various roles.
 A role model is an abstraction of an object structure.
 we can group behaviors into cohesive groups of responsibilities related to the object’s intended role

Entity Role Stereotypes
* Information holder – an object designed to know certain information and provide that information to other objects.
* Structurer – an object that maintains relationships between objects and information about those relationships.
* Service provider – an object that performs specific work and offers services to others on demand.
* Controller – an object designed to make decisions and control a complex task.
* Coordinator – an object that doesn’t make many decisions but, in a rote or mechanical way, delegates work to other objects.
* Interfacer – an object that transforms information or requests between distinct parts of a system.

      ***http://aspiringcraftsman.com/2011/12/08/solid-javascript-single-responsibility-principle/


SLIDE 5 C ==============================================================================================
SRP KATA



SLIDE 6 ==============================================================================================
  * Open/closed
    - Foundation for building reusable maintainable code
    - Abstractions
        * open for extension -> the ability for an entity to be adapted when changes occur
        * closed to modification. -> the change should not modify the behaviour of the element.

  Applying the open-closed principle:
      -> loose coupling
      -> improve readability
      -> reducing the risk of breaking existing functionality.

SLIDE 6 B ==============================================================================================


SLIDE 7 ==============================================================================================
  * Liskov substitution
    if S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that program
    - extension of the OCP
      -> “a violation of LSP is a latent violation of OCP”.

  Any extended entity should be able to replace the entity which it is an extension of without modifiyng behavior of application

SLIDE 7 B ==============================================================================================



SLIDE 8 ==============================================================================================
  * Interface segregation
cont from http://aspiringcraftsman.com/2012/01/08/solid-javascript-the-interface-segregation-principle/  An entity should not have any methods that it does not use

SLIDE 9 ==============================================================================================
  * Dependency inversion
  cont from   http://aspiringcraftsman.com/2012/01/22/solid-javascript-the-dependency-inversion-principle/
    “High level modules should not depend on low level modules rather both should depend on abstraction. Abstraction should not depend on details; rather detail should depend on abstraction.”

      Abstractions
    ---------------
      Concretions

    - Dependency Injection

SLIDE 10 ==============================================================================================
Conclusion